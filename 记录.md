# 修改记录
这里记录一下在此分支上修改的东西

目标:
- 搞清楚向量化计算
- 模仿已有的向量化计算代码, 添加代码

## 基本的数据结构
参考官方讲解https://pingcap.com/blog-cn/tidb-source-code-reading-10/

Chunk数据结构的定义, 其实就是内部存了若干个column结构
```go
// Chunk stores multiple rows of data in Apache Arrow format.
// See https://arrow.apache.org/docs/memory_layout.html
// Values are appended in compact format and can be directly accessed without decoding.
// When the chunk is done processing, we can reuse the allocated memory by resetting it.
type Chunk struct {
	columns []*column
	// numVirtualRows indicates the number of virtual rows, witch have zero columns.
	// It is used only when this Chunk doesn't hold any data, i.e. "len(columns)==0".
	numVirtualRows int
}
```

而column结构是这样的, 表示的是一列数据:
```go
type column struct {
	length     int
	nullCount  int
	nullBitmap []byte
	offsets    []int32
	data       []byte
	elemBuf    []byte
}
```

这里呢, data是用来实际存储数据的内存, length表示这个列的行数, nullCount表示空数据行的个数, nullBitmap是用来标识具体哪些行是空行的bitmap, 0标识null, 1标识非null, offsets是给变长的列使用的，存储每个数据在 data 这个数组中的偏移量, elemBuf是给定长的列用的, 读写数据的时候会利用elemBuf来标准化每行的内存格式(充当一个读写的缓存).

有了基本数据结构Column, 可以逻辑上拓展出对应的Row, 一个Row其实就是一组Column中特定的某一行, 内存上这些数据并不是连续的.

```go
// Row represents a row of data, can be used to assess values.
type Row struct {
	c   *Chunk
	idx int
}
```

## 官方提供的例子

### 定长Column的向量化计算例子

下面是一个向量化计算log10的代码的例子

```go
func (b *builtinLog10Sig) vecEvalReal(input *chunk.Chunk, result *chunk.Column) error {
	if err := b.args[0].VecEvalReal(b.ctx, input, result); err != nil {
		return err
	}
	f64s := result.Float64s()
	for i := 0; i < len(f64s); i++ {
		if result.IsNull(i) {
			continue
		}
		if f64s[i] <= 0 {
			result.SetNull(i, true)
		} else {
			f64s[i] = math.Log10(f64s[i])
		}
	}
	return nil
}

func (b *builtinLog10Sig) vectorized() bool {
	return true
}

```

builtinLog10Sig是内置函数的类型, vectorized函数返回这个内置函数是否已被向量化, vecEvalReal函数计算得到这个内置函数的real类型的计算结果, input就是输入参数(一个chunk), result是计算结果(一个Column)

可以看出来, 这个log10的向量化计算函数, 流程是这样的:
1. b.args[0].VecEvalReal(b.ctx, input, result)的作用存疑, 待研究
2. f64s := result.Float64s()取出Column中存储float64的连续内存块类型转换成[]float64类型并取出, 这样方便后续计算. 官方解释为: "相比于调用 Column 的接口，需要的 CPU 指令更少，性能更好。同时，转换后的 Slice 仍然引用着 Column 中的内存，修改后不用将数据从 Slice 拷贝到 Column 中，开销降到了最低。"
3. 一个for循环遍历f64s, 跳过null的元素, 计算math.log10(f64s[i])
4. 向量化计算就这样完成了

```go
type builtinLog10Sig struct {
	baseBuiltinFunc
}

```

builtinLog10Sig组合继承了baseBuiltinFunc, 而baseBuiltinFunc是这样定义的
```go
// baseBuiltinFunc will be contained in every struct that implement builtinFunc interface.
type baseBuiltinFunc struct {
	bufAllocator columnBufferAllocator
	args         []Expression
	ctx          sessionctx.Context
	tp           *types.FieldType
	pbCode       tipb.ScalarFuncSig

	childrenVectorizedOnce *sync.Once
	childrenVectorized     bool
}
```

在此猜测b.args[0].VecEvalReal(...)的作用, 是先计算得到函数输入参数的表达式的值, 然后再进行向量函数计算, args是[]Expression类型

### 非定长Column的向量化计算例子
下面看一个计算非定长Column的例子, builtinRepeatSig

```go
func (b *builtinRepeatSig) vecEvalString(input *chunk.Chunk, result *chunk.Column) error {
	n := input.NumRows()
	buf, err := b.bufAllocator.get(types.ETString, n)
	if err != nil {
		return err
	}
	defer b.bufAllocator.put(buf)
	if err := b.args[0].VecEvalString(b.ctx, input, buf); err != nil {
		return err
	}

	buf2, err := b.bufAllocator.get(types.ETInt, n)
	if err != nil {
		return err
	}
	defer b.bufAllocator.put(buf2)
	if err := b.args[1].VecEvalInt(b.ctx, input, buf2); err != nil {
		return err
	}

	result.ReserveString(n)
	nums := buf2.Int64s()
	for i := 0; i < n; i++ {
		// TODO: introduce vectorized null-bitmap to speed it up.
		if buf.IsNull(i) || buf2.IsNull(i) {
			result.AppendNull()
			continue
		}
		num := nums[i]
		if num < 1 {
			result.AppendString("")
			continue
		}
		if num > math.MaxInt32 {
			// to avoid overflow when calculating uint64(byteLength)*uint64(num) later
			num = math.MaxInt32
		}

		str := buf.GetString(i)
		byteLength := len(str)
		if uint64(byteLength)*uint64(num) > b.maxAllowedPacket {
			b.ctx.GetSessionVars().StmtCtx.AppendWarning(errWarnAllowedPacketOverflowed.GenWithStackByArgs("repeat", b.maxAllowedPacket))
			result.AppendNull()
			continue
		}
		if int64(byteLength) > int64(b.tp.Flen)/num {
			result.AppendNull()
			continue
		}
		result.AppendString(strings.Repeat(str, int(num)))
	}
	return nil
}
```

这个函数大概的流程是这样的:
1. 先申请获取两块内存, 分别叫buf和buf2, 里面分别存了这个向量化计算函数输入的两个参数, 也就是字符串向量和int向量, 最终需要完成的功能就是, 让字符串向量里每个分量的字符串都重复对应的int向量分量次数.
2. result.ReserveString(n), 提前在result Column中申请空间
3. for循环中, 跳过null的分量
4. 跳过uint64(byteLength)*uint64(num) > b.maxAllowedPacket的情况
5. 跳过int64(byteLength) > int64(b.tp.Flen)/num的情况
6. 若没有其他异常情况, 则把重复后的字符串append进result Column

主要的逻辑在于判断各种异常情况, b.maxAllowedPacket和b.tp.Flen的含义需要搞清楚, 我看下builtinRepeatSig的定义, 就是在组合继承了baseBuiltinFunc的基础上加入了maxAllowedPacket限制,至于为什么要加这个限制, **存疑, 待研究**.

```go
type builtinRepeatSig struct {
	baseBuiltinFunc
	maxAllowedPacket uint64
}
```

### 尝试改进builtinRepeatSig

代码中有一个TODO, introduce vectorized null-bitmap to speed it up.

尝试利用了null-bitmap, 修改后的函数如下

```go
	buf.MergeNulls(buf2)
	for i := 0; i < n; i++ {
		// TODO: introduce vectorized null-bitmap to speed it up.
		if buf.IsNull(i) {
			result.AppendNull()
			continue
		}

		num := nums[i]
		if num < 1 {
			result.AppendString("")
			continue
		}
		if num > math.MaxInt32 {
			// to avoid overflow when calculating uint64(byteLength)*uint64(num) later
			num = math.MaxInt32
		}

		str := buf.GetString(i)
		byteLength := len(str)
		if uint64(byteLength)*uint64(num) > b.maxAllowedPacket {
			b.ctx.GetSessionVars().StmtCtx.AppendWarning(errWarnAllowedPacketOverflowed.GenWithStackByArgs("repeat", b.maxAllowedPacket))
			result.AppendNull()
			continue
		}
		if int64(byteLength) > int64(b.tp.Flen)/num {
			result.AppendNull()
			continue
		}
		result.AppendString(strings.Repeat(str, int(num)))
	}

```

下面进行单元测试
```bash
go test -check.f TestVectorizedBuiltinStringFunc
```

单元测试通过, 接下来进行性能测试
```bash
go test -v -benchmem -bench=BenchmarkVectorizedBuiltinStringFunc -run=BenchmarkVectorizedBuiltinStringFunc
```

测试下来效果并不十分理想....猜测可能是由于测试用例的原因, 可能需要在特定情况的测试用例下, 才会有比较明显的性能差别.

## 疑问
expression/column.go line 263

```go
// VecEvalString evaluates this expression in a vectorized manner.
func (col *Column) VecEvalString(ctx sessionctx.Context, input *chunk.Chunk, result *chunk.Column) error {
	if col.RetType.Hybrid() {
		it := chunk.NewIterator4Chunk(input)
		result.ReserveString(input.NumRows())
		for row := it.Begin(); row != it.End(); row = it.Next() {
			v, null, err := col.EvalString(ctx, row)
			if err != nil {
				return err
			}
			if null {
				result.AppendNull()
			} else {
				result.AppendString(v)
			}
		}
		return nil
	}
	input.Column(col.Index).CopyReconstruct(input.Sel(), result)
	return nil
}
```

**前面对result进行了赋值, 但最后却调用了CopyReconstruct对result进行了重置??????**