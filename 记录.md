# 修改记录
这里记录一下在此分支上修改的东西

目标:
- 搞清楚向量化计算
- 模仿已有的向量化计算代码, 添加代码

## 基本的数据结构
参考官方讲解https://pingcap.com/blog-cn/tidb-source-code-reading-10/

Chunk数据结构的定义, 其实就是内部存了若干个column结构
```go
// Chunk stores multiple rows of data in Apache Arrow format.
// See https://arrow.apache.org/docs/memory_layout.html
// Values are appended in compact format and can be directly accessed without decoding.
// When the chunk is done processing, we can reuse the allocated memory by resetting it.
type Chunk struct {
	columns []*column
	// numVirtualRows indicates the number of virtual rows, witch have zero columns.
	// It is used only when this Chunk doesn't hold any data, i.e. "len(columns)==0".
	numVirtualRows int
}
```

而column结构是这样的, 表示的是一列数据:
```go
type column struct {
	length     int
	nullCount  int
	nullBitmap []byte
	offsets    []int32
	data       []byte
	elemBuf    []byte
}
```

这里呢, data是用来实际存储数据的内存, length表示这个列的行数, nullCount表示空数据行的个数, nullBitmap是用来标识具体哪些行是空行的bitmap, 0标识null, 1标识非null, offsets是给变长的列使用的，存储每个数据在 data 这个数组中的偏移量, elemBuf是给定长的列用的, 读写数据的时候会利用elemBuf来标准化每行的内存格式(充当一个读写的缓存).

有了基本数据结构Column, 可以逻辑上拓展出对应的Row, 一个Row其实就是一组Column中特定的某一行, 内存上这些数据并不是连续的.

```go
// Row represents a row of data, can be used to assess values.
type Row struct {
	c   *Chunk
	idx int
}
```

## 官方提供的例子
下面是一个向量化计算log10的代码的官方例子

```go
func (b *builtinLog10Sig) vecEvalReal(input *chunk.Chunk, result *chunk.Column) error {
	if err := b.args[0].VecEvalReal(b.ctx, input, result); err != nil {
		return err
	}
	f64s := result.Float64s()
	for i := 0; i < len(f64s); i++ {
		if result.IsNull(i) {
			continue
		}
		if f64s[i] <= 0 {
			result.SetNull(i, true)
		} else {
			f64s[i] = math.Log10(f64s[i])
		}
	}
	return nil
}

func (b *builtinLog10Sig) vectorized() bool {
	return true
}

```

builtinLog10Sig是内置函数的类型, vectorized函数返回这个内置函数是否已被向量化, vecEvalReal函数计算得到这个内置函数的real类型的计算结果, input就是输入参数(一个chunk), result是计算结果(一个Column)

可以看出来, 这个log10的向量化计算函数, 流程是这样的:
1. b.args[0].VecEvalReal(b.ctx, input, result)的作用存疑, 待研究
2. f64s := result.Float64s()取出Column中存储float64的连续内存块类型转换成[]float64类型并取出, 这样方便后续计算. 官方解释为: "相比于调用 Column 的接口，需要的 CPU 指令更少，性能更好。同时，转换后的 Slice 仍然引用着 Column 中的内存，修改后不用将数据从 Slice 拷贝到 Column 中，开销降到了最低。"
3. 一个for循环遍历f64s, 跳过null的元素, 计算math.log10(f64s[i])
4. 向量化计算就这样完成了

```go
type builtinLog10Sig struct {
	baseBuiltinFunc
}

```

builtinLog10Sig组合继承了baseBuiltinFunc, 而baseBuiltinFunc是这样定义的
```go
// baseBuiltinFunc will be contained in every struct that implement builtinFunc interface.
type baseBuiltinFunc struct {
	bufAllocator columnBufferAllocator
	args         []Expression
	ctx          sessionctx.Context
	tp           *types.FieldType
	pbCode       tipb.ScalarFuncSig

	childrenVectorizedOnce *sync.Once
	childrenVectorized     bool
}
```

在此猜测b.args[0].VecEvalReal(...)的作用, 是先计算得到函数输入参数的表达式的值, 然后再进行向量函数计算, args是[]Expression类型